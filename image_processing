void main()
{
	/*
	1장 영상처리의 개요

영상 처리 (image processing)란 영상을 대상으로 하는 신호 처리(signal processing) 의 한 분야로서 영상으로 부터 원하는 정보를 얻기 위해 행하는 모든 종류의 처리를 의미함.

영상처리에서 주로 다루는 분야는 영상의 화질 향상, 소실된 정보의 복원, 데이터의 압축, 영상의 인식등임.
일반적으로 영상은 2차원 배열의 형태로 표현되기 때문에 2차원 평면 공간에서 다양한 신호 처리 기법을 이용하여 원하는 결과를 얻음.

분야
영상의 화질 향상
영상의 기하학적 변환
영상 분할
객체의 모양 기술
객체 인식
영상 압축
동영상 처리

영상의 화질 향상은 전체적으로 어두운 영상을 밝게 만들거나 흐린 영상을 선명하게 만드는 작업이고 기하학적 변환은 영상의 이동 변환, 크기 변환, 회전 변환 등을 이용하여 영상의 전체적인 형태를 변형하는 것을 의미함.
영상분할은 영상을 객체와 배경을 분리하거나 영상을 의미 있는 영역으로 구분하는 작업임

 ⭐ 영상 표현 방법

주로 사용하는 영상은 그레이스케일 (grayscale) 영상이고 그레이스케일 영상이란 색상 정보 없이 오직 밝은 정보만으로 구성된 영상을 의미하며 흑백 사진처럼 검정색, 회색, 흰색으로 구분되어 있음.
반대로 트루 컬러 영상(true-color) 영상은 색상 정보를 가지고 있어 다양한 색상을 표현할 수 있는 것임.
영상의 기본 단위:  픽셀 (pixel)
그레이스케일 영상에서 하나의 픽셀은 0부터 255 사이의 정수값을 가짐.
컴퓨터는 1바이트에 256가지의 수를 표현할 수 있는데 
하나의 픽셀을 표현하기 위해서 컴퓨터에서 1바이트의 메모리 공간을 사용하기 때문임.
픽셀이 0이면 검정색, 255이면 흰색 그 중간은 회색임.
0 ~ 255 정수 값의 범위를 그레이스 범위라고함.

영상은 픽셀이 바둑판처럼 균일한 격자 형태로 배열되어 있는 형태로 표현됨.
가로 크기가 M, 세로 크기가 N인데 
가로 좌표는 0 부터 M-1 까지 증가하고,
세로 좌표는 0 부터 N-1 까지 감소하고 이것을 0-based 표현이라고함

⭐ 2차원 배열 처리

가로 크기 640, 세로 크기 480인 그레이스케일 영상 데이터를 저장할 배열을 만들려면
unsigned char a[480][640];
으로 해야함.
unsigned char 자료형은 1바이트 크기를 가지고 0 ~ 255까지의 정수를 저장 가능
앞서 그레이스케일 영상에서 픽셀이 가질 수 있는 값의 범위도 0 ~ 255까지 라고 하여서 가장 적합한 자료형임. 참고로 unsigned 키워드가 없는 일반적인 char 자료형은 -127 ~ 127 정수 저장 가능함.

2차원 배열의 크기를 지정하는 방법에 대해 알아보자면 일반적인 c/c++ 배열은 처음 선언할 때 배열의 크기를 상수로 지정하여 생성해야만 하며, 이처럼 크기가 처음에 고정된 배열 생성 방식을 정적 배열 (static array) 생성 이라고 함.
2차원 배열을 선언할 때 2 개의 괄호([ ]) 중 첫 번째 괄호에 y축에 해당하는 크기를 입력하고  두 번째 괄호에 x축에 해당하는 크기를 입력함.

c/c++ 에서 2차원 배열을 선언하면 실제 메모리 공간에서는 2차원 배열 전체 크기만큼의 메모리 공간이 연속적으로 할당됨. 즉 640x480 =307200이므로 앞의 배열 선언이나
unsigned char a[307200]; 배열 선언이나 메모리는 동일한 크기로 연속적으로 할당됨
다만 2차원 배열로 선언하면 각 배열 원소에 2차원 배열 방식을 따르게 됨.

a[0][0] a[0][1]`````````a[0][639]
a[1][0]``````````````````a[1][639]
``````````````````````````````````````
a[479][0]```````````````a[479][639]

그러나 실제로는 2차원 배열을 이용하여 표현하는 일은 거의 없음.
정적으로 생성된 배열은 선언시 배열의 크기로 상수 형태로 지정해주어야 하기 때문에 다양한 크기의 영상을 다루기 적합하지 않음.
그래서 배열의 크기를 결정할 수 있는 동적 배열(dynamic array)을 주로 사용함.

⭐ 2차원 동적 배열
이중 포인터를 이용해 생성
가로 크기가 w,세로 크기가 h인 영상 을 표현하는 2차원 배열 

unsigned char** p;
p = new unsigned char*[h];

for(int i = 0; i < h; i++)
{
   p[i] = new unsigned char[w];
}  

일단 unsigned char 포인터 타입의 메모리 공간을 h 크기만큼으로 동적 할당하고
다시 w 크기만큼의 공간을 h 횟수만큼 동적 할당함.
p[0][0]으로 접근하거나 p[h-1][w-1]으로 접근 가능

p는 이중포인터(unsigned char**)이고, p[0]부터 p[h-1] 까지는 동적 할당으로 생성된 포인터 (unsigned char*) 타입의 공간이고
포인터형 변수는 32비트 운영체제에서는 4바이트의 크기를 가지고
64비트 운영체제에서는 8바이트의 크기를 갖음.
실제 저장되는 데이터 공간은 unsigned char 타입이므로 각 1바이트의 크기를 갖음

new 연산자에 의해서 동적 생성된 메모리 공간은 쓰레기 값이라고 부르는 임의의 값들이 들어가 있는데 만약 2차원 배열을 동적 생성하면서 그 내부의 값을 모두 0으로 초기화한다면 

#include <memory.h>
````
unsigned char **p;
p =  new unsigned char*[h];
for (int i = 0; i < h; i ++)
{
         p[i] = new unsigned char[w];
         memset(p[i], 0 , sizeof(unsigned char ) * w);
}
memset(p[i], 0 , sizeof(unsigned char ) * w); 
-> 의미는 p[i] 가 가리키는 메모리 공간으로 부터 sizeof(unsigned char)*w에 해당하는 크기의 메모리 공간을 모두 0으로 채운다는 것임.

그러면 2차원 배열의 원소에 접근하는 방법은 for루프 2개를 이용하는 것임

for (int j = 0; j < h; j ++)
{
   for (int i = 0; i < w; i++)
  {
         p[ j ] [ i ] = p[ j ][ i ] + 1;
  }
}

w는 배열의 가로 크기, h는 배열의 세로 크기 이며 for문의 바깥쪽은 y축에 대한 for루프이고
안쪽은 x축에 대한 for 루프임 
i는 x축의 좌표이고 j는 y축의 좌표임.

주의) unsigned char로 설정해 p[ i ] [ j ] 에 저장할 수 있는 값은 0 ~ 255인데
이 범위로 벗어나는 경우, 자동으로 0 ~ 255로 변환되어 저장됨
예를 들어 현재 p [ j ] [ i ] 에 들어있는 값이 255일때  
 p[ j ][ i ] + 1 에 해당하는 값은 256이지만 실제로는 p[ j ] [ i ] = p[ j ][ i ] + 1; 이 코드로 인해
새로 변경되는  p [ j ] [ i ] 값은 0으로 바뀌어 저장됨

가독성 높이기 위해 종종 이중 for루프를 다음과 같이 씀

for (int j = 0; j < h; j ++)
for (int i = 0; i < w; i++)
{
   p[ j ] [ i ] = p[ j ][ i ] + 1;
}

동적으로 생성된 배열은 사용이 끝나면 반드시 메모리를 해제해줘야 함.
지역변수로 선언된 정적 배열은 그 배열을 사용한 블록 또는 함수가 종료되면 자동으로 메모리 공간이 사라지지만 동적 배열은 사용자가 직접 메모리 공간을 해제해줘야 함.

동적 배열을 해제하는 방법은 할당하는 방법의 반대임.
for (int i = 0; i < h; i++)
       delete[]   p[i];  —-->     동적 할당된 데이터 공간으로 표현한 메모리 해제하는 방법
delete[] p;       —---->   동적 할당된 포인터형 공간으로 표현한 메모리 해제하는 방법

⭐ 변형된 2차원 배열 동적 할당

앞선 방법은 동적 할당된 전체 메모리 공간이 연속적이라고 100% 보장할 수 없기 때문에 전체 픽셀을 1차원 배열처럼은 사용할 수 없고 경우에 따라서 2차원 영상을 1차원 데이터처럼 사용하는 것이 필요할 때가 있음

아래 코드는 하나의 영상을 단일 메모리 블록으로 할당하고 이를 2차원 배열과 동일한 방식으로 접근할 수 있는 방법임.

#include <memory.h>
`````````
unsigned char** p;
p = new unsigned char*[h];
p[0] = new unsigned char [ w * h ];
for (int i =1 ; i < h; i ++)
       p[i] = p [ i - 1 ] + w;
memset( p[0] , 0,  w*h );

new 연산자로 메모리를 할당하는 작업은 2 번만 발생함.
일단 unsigned char * 타입의 메모리 공간을 h 크기 만큼 동적 할당하여 p에 저장
그래서 p [0] 부터 p [ h-1] 까지 모두 unsigned char * 타입을 저장할 수 있게 됨
이 중 첫 번째 p[ 0 ] 은 영상 전체 크기 ( w * h ) 에 해당하는 메모리 공간을 할당하여 그 주소를 받게 하였고 나머지 p[1] 부터 p [ h-1 ] 까지는 실질적인 new 연산자에 의해서 동적 할당 하지 않고 p[0] 이 가리키고 있는 영상 전체 메모리 영역의 특정 주소를 가리키도록 설정되어 있음

for 문 이용

unsigned char *p1 = p[0];
for ( int i = 0; i < w * h ; i ++)
{
     p1[ i ] = p1 [ i ] + 1;
}

똑같이 사용자가 직접 메모리를 해제해줘야 함
delete[] p[0];
delete p;

실제로 new 연산자로 메모리 공간을 할당받은 것이 2 번이므로 delete[] 연산을 하는 것도 2번으로 충분함. 하지만 위의 순서는 지켜야 함.



	*/
}
